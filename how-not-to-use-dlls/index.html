<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>How not to use DLLs</title>
    <meta name="description" content="Technobabble and nonsense">

    <link rel="stylesheet" href="https://h3.gd/main.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    

    
    
</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;h3.gd">h3r2tic&#x27;s grimoire</a>
            </h1>
            <nav>
                <a href="https://github.com/h3r2tic/"><i class="fa fa-github"></i></a>
                <a href="https://twitter.com/h3r2tic/"><i class="fa fa-twitter"></i></a>

                
                
                
                <a  href="https:&#x2F;&#x2F;h3.gd&#x2F;about&#x2F;">About</a>
                
                
            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>How not to use DLLs</h1>
    </header>
    <div class="content">
        <p>Runtime loading of object files, relocation of DLLs. Mostly harmful stuff.</p>
<span id="continue-reading"></span><h1 id="disclaimer">Disclaimer</h1>
<p>The code described in this note doesn't really aim to be pragmatic. Treat it as a curiosity rather than a recommendation. In fact, you probably don't want to use any of this nonsense in production environments (or even in most experimental environments).</p>
<h1 id="introduction">Introduction</h1>
<p>Back in a previous life when I was a D programmer, I contributed to a project called <a href="http://www.dsource.org/projects/ddl"><em>D Dynamic Libraries</em></a>. It was a pretty crazy system which on Windows provided means of loading plugins without the need for DLLs. <em>DDL</em> would load compiler-generated object files directly, and link them at runtime. For the D language it was a pretty major deal, as DLLs were severely broken at the time.</p>
<p>When I recently overheard <a href="https://twitter.com/gwihlidal">@gwihlidal</a> and <a href="https://twitter.com/repi">@repi</a> discuss their annoyances with DLLs, I figured "hold my beer", and went on to re-implement an ad-hoc version of <em>D Dynamic Libraries</em> in C++.</p>
<p>What are the annoyances? Here's a couple:</p>
<ol>
<li>Duplication of symbols</li>
<li>Windows locking the DLL files while they're loaded</li>
</ol>
<p>Symbol duplication can cause problems with anything using globals; singletons will not be lonely either. They end up fully defined in both the host and plugins, rather than provided by just one (the host). This may impact RTTI systems, allocators, logging, etc. It also means potentially longer link times and plugins larger than they should be.</p>
<p>I used to think this was a hard limitation of DLLs, in that they could not pull symbols from the host. It turns out that I was mistaken; one can use <em>dllexport</em> in the host, <em>dllimport</em> in the plugin, create an <em>import library</em> for the host, and provide it when linking the DLL. <a href="https://github.com/mesonbuild/meson/issues/1623">Here's one example I found</a>. When I tried it, the <em>dllexport</em> wasn't actually <em>needed</em> for functions, but it was necessary for variables. If you don't have full control over all code, it might be tricky to add <em>dllimport</em> to all the globals.</p>
<p>One might actually argue that #1 is a Good Thing as it enforces strict separation between the host and plugins, and results in cleaner architectures. But I'm not here to argue that (see disclaimer).</p>
<p><img alt="Your scientists were so preoccupied with whether or not they could, they didn’t stop to think if they should" src="forScience.jpg" style="width: 75%"></img></p>
<p>Item #2 mostly pops up when rolling a code hot-swap system. It can be easily worked around, but if we reinvent the wheel, we don't need to work around it :P</p>
<h1 id="running-code-from-object-files">Running code from object files</h1>
<p>Suppose we have a <em>plugin.cpp</em> file with a simple function like this:</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">foo</span><span>(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">a</span><span>, </span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">b</span><span>) {
</span><span>	</span><span style="color:#8fbfdc;">return</span><span> a + b;
</span><span>}
</span></code></pre>
<p>When we compile it, the resulting object file will contain the final executable code. We can actually just <em>fread()</em> it, find the location of the machine code, and call it. In order to appease Windows, we need to mark the memory executable with <em>VirtualProtect()</em>, but that's basically it:</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">main</span><span>()
</span><span>{
</span><span>	CoffBinary coff;
</span><span>	</span><span style="color:#8fbfdc;">if </span><span>(</span><span style="color:#ffb964;">openCoff</span><span>(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">plugin.obj</span><span style="color:#556633;">&quot;</span><span>, &amp;coff)) {
</span><span>		coff.</span><span style="color:#ffb964;">parse</span><span>();
</span><span>
</span><span>		</span><span style="color:#8fbfdc;">unsigned long</span><span> prevProtect;
</span><span>		</span><span style="color:#ffb964;">VirtualProtect</span><span>(
</span><span>			coff.</span><span style="color:#ffb964;">rawData</span><span>, coff.</span><span style="color:#ffb964;">rawDataSize</span><span>,
</span><span>			PAGE_EXECUTE_READWRITE, &amp;prevProtect);
</span><span>
</span><span>		</span><span style="color:#8fbfdc;">auto</span><span> foo = (</span><span style="color:#8fbfdc;">int</span><span>(*)(</span><span style="color:#8fbfdc;">int</span><span>, </span><span style="color:#8fbfdc;">int</span><span>))
</span><span>			(coff.</span><span style="color:#ffb964;">rawData </span><span>+ coff.</span><span style="color:#ffb964;">sections</span><span>[</span><span style="color:#cf6a4c;">2</span><span>].</span><span style="color:#ffb964;">PointerToRawData</span><span>);
</span><span>		printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">foo(2, 3) = </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>, </span><span style="color:#ffb964;">foo</span><span>(</span><span style="color:#cf6a4c;">2</span><span>, </span><span style="color:#cf6a4c;">3</span><span>));
</span><span>	}
</span><span>
</span><span>	getchar();
</span><span>	</span><span style="color:#8fbfdc;">return </span><span style="color:#cf6a4c;">0</span><span>;
</span><span>}
</span></code></pre>
<p><img src="https://h3.gd/how-not-to-use-dlls/runobj1.png" alt="" /></p>
<p>Here I'm using a simple parser for the <em>Common Object File Format</em> (COFF) which I quickly cobbled together using <a href="http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx">Microsoft's PE/COFF specification</a>.</p>
<p>Things get more complicated when our function tries to reference other symbols, e.g.:</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">cstdio</span><span style="color:#556633;">&gt;
</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">foo</span><span>(</span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">a</span><span>, </span><span style="color:#8fbfdc;">int </span><span style="color:#ffb964;">b</span><span>) {
</span><span>	puts(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">foo called()</span><span style="color:#556633;">&quot;</span><span>);
</span><span>	</span><span style="color:#8fbfdc;">return</span><span> a + b;
</span><span>}
</span></code></pre>
<p><img src="https://h3.gd/how-not-to-use-dlls/runobj2.png" alt="" /></p>
<p>We get a crash because the code is trying to perform a call to an unresolved function.</p>
<p><img src="https://h3.gd/how-not-to-use-dlls/runobj3.png" alt="" /></p>
<p>The generated call address is relative to the next instruction, and by default that offset is zero:</p>
<p><img src="https://h3.gd/how-not-to-use-dlls/runobj4.png" alt="" /></p>
<h2 id="runtime-linking">Runtime linking</h2>
<p>In order to run this code we need to <em>resolve</em> all unreferenced symbols. We do this by <em>linking</em> the loaded binary image to our application at runtime.</p>
<p>An object file contains a number of sections, each potentially comprising data, executable code, debug symbols, and other stuff. Each section also contains a list of relocations. A relocation is a triple of:</p>
<ul>
<li><strong>Offset into the section</strong> specifying a location where the relocation must be applied</li>
<li><strong>Index of the symbol</strong> that the location must be adjusted to point at</li>
<li><strong>Type</strong> of the relocation</li>
</ul>
<img src="reloc.png" style="width: 75%" />
<p>In our simple case, the relocation type is a 32-bit offset relative to the next instruction. It means that the value we write when performing the relocation is not the address of the target symbol, but the offset to it from the address following the one we write. There are a few other relocation types, for example absolute 64-bit ones, but we only need to handle one type here.</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#888888;">// Initialize DbgHelp so we can look-up symbols in the host.
</span><span style="color:#ffb964;">SymInitialize</span><span>(</span><span style="color:#ffb964;">GetCurrentProcess</span><span>(), nullptr, TRUE);
</span><span>
</span><span style="color:#8fbfdc;">for </span><span>(</span><span style="color:#8fbfdc;">auto</span><span>&amp; rel : coff.</span><span style="color:#ffb964;">getSectionRelocations</span><span>(coff.</span><span style="color:#ffb964;">sections</span><span>[</span><span style="color:#cf6a4c;">3</span><span>])) {
</span><span>	CoffBinary::Symbol&amp; sym = coff.</span><span style="color:#ffb964;">symbols</span><span>[rel.</span><span style="color:#ffb964;">SymbolTableIndex</span><span>];
</span><span>	</span><span style="color:#8fbfdc;">char</span><span>* relSource = nullptr;
</span><span>
</span><span>	</span><span style="color:#8fbfdc;">if </span><span>(CoffBinary::SymClassStatic == sym.</span><span style="color:#ffb964;">StorageClass</span><span>) {
</span><span>		</span><span style="color:#888888;">// Reference to a static data segment in the OBJ
</span><span>		relSource =
</span><span>			coff.</span><span style="color:#ffb964;">rawData </span><span>+
</span><span>			coff.</span><span style="color:#ffb964;">sections</span><span>[sym.</span><span style="color:#ffb964;">SectionNumber </span><span>- </span><span style="color:#cf6a4c;">1</span><span>].</span><span style="color:#ffb964;">PointerToRawData </span><span>+
</span><span>			sym.</span><span style="color:#ffb964;">Value</span><span>;
</span><span>	} </span><span style="color:#8fbfdc;">else if </span><span>(CoffBinary::SymClassExternal == sym.</span><span style="color:#ffb964;">StorageClass</span><span>) {
</span><span>		</span><span style="color:#888888;">// External reference. Use DbgHelp to find symbol in host app
</span><span>		SYMBOL_INFO symbol = {};
</span><span>		symbol.</span><span style="color:#ffb964;">SizeOfStruct </span><span>= sizeof(SYMBOL_INFO);
</span><span>		std::string symName = coff.</span><span style="color:#ffb964;">decodeString</span><span>(sym.</span><span style="color:#ffb964;">Name</span><span>);
</span><span>		</span><span style="color:#8fbfdc;">if </span><span>(</span><span style="color:#ffb964;">SymFromName</span><span>(</span><span style="color:#ffb964;">GetCurrentProcess</span><span>(), symName.</span><span style="color:#ffb964;">c_str</span><span>(), &amp;symbol)) {
</span><span>			relSource = (</span><span style="color:#8fbfdc;">char</span><span>*)symbol.</span><span style="color:#ffb964;">Address</span><span>;
</span><span>		}
</span><span>	}
</span><span>
</span><span>	</span><span style="color:#888888;">// Address that needs patching up
</span><span>	</span><span style="color:#8fbfdc;">char</span><span>* relTarget = coff.</span><span style="color:#ffb964;">rawData </span><span>+
</span><span>		coff.</span><span style="color:#ffb964;">sections</span><span>[</span><span style="color:#cf6a4c;">3</span><span>].</span><span style="color:#ffb964;">PointerToRawData </span><span>+ rel.</span><span style="color:#ffb964;">VirtualAddress</span><span>;
</span><span>
</span><span>	</span><span style="color:#888888;">// Write relative offset. Next instruction is 4 bytes after destination.
</span><span>	*(</span><span style="color:#8fbfdc;">int</span><span>*)relTarget = relSource - relTarget - </span><span style="color:#cf6a4c;">4</span><span>;
</span><span>}
</span></code></pre>
<p>Now when we run our app, we get the following:</p>
<p><img src="https://h3.gd/how-not-to-use-dlls/runobj5.png" alt="" /></p>
<p>This is a basic version of runtime linking which completely bypasses DLL files. In <a href="https://github.com/h3r2tic/runobj">my github repository</a> you can find a slightly more complete implementation which doesn't arbitrarily resolve only section three. It uses a different <a href="https://github.com/serge1/COFFI">COFF parser</a> which I had borrowed from Serge Lamikhov-Center before I wrote my own. The sample also reads the host's MAP file to extract information about symbol locations, as even DbgHelp fails to find them all.</p>
<p>In practice one would also need to resolve multiple object files against each other, handle all relocation types, potentially create exception frames, and then some.</p>
<p>I didn't get that far though.</p>
<img src="runobj6.png" style="width: 75%" />
<p>I got kinda stuck at trying to make Visual Studio's debugger load the debug info for the manually linked code. There are WinApi functions like <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680588(v=vs.85).aspx">RtlAddFunctionTable</a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680664(v=vs.85).aspx">SymAddSymbol</a> which in theory can be used to feed extra symbols and debug info to DbgHelp and the CRT. It seems however that debuggers don't use whatever information the executable provides via those APIs, and have their own view of the debugee's symbols.</p>
<p>If you know a trick to get debug symbols to work with manual code loading, and it doesn't involve writing a debug engine, I would be very curious to learn about it. In the meantime though...</p>
<h1 id="going-back-to-dlls">Going back to DLLs</h1>
<p>At this stage I had a working COFF reader/writer, and I was ready to get nasty. I figured that in order to get debug info, I had to use DLLs after all. Surely if it's possible to manually link object files, something similar could be done to DLLs.</p>
<p>The idea is to create a "broken" DLL with unreferenced/invalid symbols, load it using standard WinApi functions, and <em>then</em> link it at runtime, thus fixing it. How do we create that "broken" DLL? Glad you asked.</p>
<ul>
<li>Modify whatever object files go into the DLL, marking unresolved symbols resolved. It's pretty simple really: if a symbol's section index is zero, set it to anything greater than zero. It's ugly but it works.</li>
<li>... just use a few flags for link.exe: <strong>/noentry /nodefaultlib /force</strong></li>
</ul>
<img src="honeyBadgerDontCare.jpg" style="width: 50%" />
<p>The latter is pretty amazing in a way. The linker will report a bunch of errors, but then still produce a DLL. We can load it just fine, but any code using the unreferenced symbols will have a bad time. Let's fix it next.</p>
<h2 id="relocating-a-dll-at-runtime">Relocating a DLL at runtime</h2>
<p>The good news is that the DLL is internally linked, meaning that references to its own symbols are properly resolved. We don't need to fix all the symbols ourselves. The bad news however is that there's no relocation table anymore, and the linker has reshuffled the contents of our object file, so we can't trivially use the relocation table from our source objects.</p>
<p><img src="https://h3.gd/how-not-to-use-dlls/relocRemapWut.png" alt="" /></p>
<p>Relocations are provided as locations within sections that need to be pointed at specific symbols. Contents of sections are moved around by the linker, but not arbitrarily -- the linker will not reshuffle every instruction. If we identify how chunks of code correlate between the objects and the final DLL, we can relocate the DLL.</p>
<p>Given an address within a section, we can find the last symbol whose location is less than or equal the address. If we sort all symbols in a section by their location, this becomes a simple binary search. Using this translation, a relocation becomes:</p>
<ul>
<li>A symbol specifying a location <em>within</em> which we need to apply the relocation</li>
<li>An offset into the symbol's location</li>
<li>The symbol at which we need to point</li>
<li>Type of relocation (rel32, addr64, etc.)</li>
</ul>
<p>We can then use a linker-generated <a href="https://msdn.microsoft.com/en-us/library/k7xkk3e2.aspx">map of the DLL</a> to look-up its symbols, and apply relocations.</p>
<p><img src="https://h3.gd/how-not-to-use-dlls/relocRemap.png" alt="" /></p>
<p>What does all this madness get us? We got debug symbols back! On the other hand, since we're once again in DLL land, Windows will insist on locking the file... At least we have gotten rid of the symbol duplication, which was the main goal. For example, this works:</p>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#888888;">// plugin.cpp
</span><span style="color:#8fbfdc;">#include </span><span style="color:#556633;">&lt;</span><span style="color:#99ad6a;">cstdio</span><span style="color:#556633;">&gt;
</span><span>
</span><span style="color:#8fbfdc;">extern int</span><span> myGlobal;
</span><span style="color:#8fbfdc;">extern </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">C</span><span style="color:#556633;">&quot; </span><span style="color:#8fbfdc;">__declspec</span><span>(</span><span style="color:#7697d6;">dllexport</span><span>) </span><span style="color:#8fbfdc;">void </span><span style="color:#fad07a;">foo</span><span>()
</span><span>{
</span><span>	printf(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">myGlobal: </span><span style="color:#7697d6;">%d</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>, myGlobal);
</span><span>}
</span></code></pre>
<pre data-lang="cpp" style="background-color:#151515;color:#e8e8d3;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#888888;">// host.cpp
</span><span style="color:#8fbfdc;">int</span><span> myGlobal = </span><span style="color:#cf6a4c;">666</span><span>;
</span><span>
</span><span style="color:#8fbfdc;">int </span><span style="color:#fad07a;">main</span><span>()
</span><span>{
</span><span>	SymbolMap hostMap = </span><span style="color:#ffb964;">parseMapFile</span><span>(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">host.map</span><span style="color:#556633;">&quot;</span><span>, (</span><span style="color:#8fbfdc;">char</span><span>*)</span><span style="color:#ffb964;">GetModuleHandle</span><span>(</span><span style="color:#cf6a4c;">0</span><span>));
</span><span>	HMODULE dll = </span><span style="color:#ffb964;">loadAndRelocatePlugin</span><span>(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">plugin</span><span style="color:#556633;">&quot;</span><span>, hostMap);
</span><span>
</span><span>	</span><span style="color:#8fbfdc;">auto</span><span> foo = (</span><span style="color:#8fbfdc;">void</span><span>(*)())</span><span style="color:#ffb964;">GetProcAddress</span><span>(dll, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">foo</span><span style="color:#556633;">&quot;</span><span>);
</span><span>
</span><span>	</span><span style="color:#ffb964;">foo</span><span>();
</span><span>	</span><span style="color:#8fbfdc;">return </span><span style="color:#cf6a4c;">0</span><span>;
</span><span>}
</span></code></pre>
<p><img src="https://h3.gd/how-not-to-use-dlls/relocdll1.png" alt="" /></p>
<p>You can grab a basic implementation of manual DLL relocation in another <a href="https://github.com/h3r2tic/relocdll">repository of mine</a>. It still only uses just one OBJ file for the plugin, but the concept should scale to more complex cases. It's still far from tested, and I might be missing some important pieces of info which might invalidate this approach. Again, take it with a grain of salt.</p>
<h1 id="32-bit-relative-addresses">32-bit relative addresses</h1>
<p>There's one more important detail I haven't covered yet; it applies to both DLL and object loading. Even on 64-bit systems, compilers will generate <a href="http://www.felixcloutier.com/x86/CALL.html">32-bit relative call</a> instructions. That is, the target address is a signed 32-bit integer specifying an offset from the instruction following the call.</p>
<p>This means that all code must sit within (realistically) a 2GB <strong>virtual memory</strong> range. A single application will easily satisfy that <em>(*cough* unless it links certain GUI middleware)</em>. When Windows loads a DLL however, it typically places it pretty far in virtual address space from the host. Compilers will generate 64-bit calls for function pointers, so calling the plugin's interface is fine, however the code within the plugin will be using lots of 32-bit offsets. Since we're linking the plugin to our host app, those 32-bit offsets are in trouble.</p>
<p>In the case of object files, we can use <em>VirtualAlloc</em> to allocate the memory for our plugin. That way we can specify the address, and make sure it will sit within a 32-bit offset from our host's code. There's no <em>LoadLibrary</em> parameter to specify the load address of a DLL though, so we need to get dirty.</p>
<p>Now, Microsoft will tell us that we should not mess with <a href="https://blogs.msdn.microsoft.com/winsdk/2009/11/30/how-to-disable-address-space-layout-randomization-aslr/">Address Layout Space Randomization</a>, but in practice we can pass <a href="https://msdn.microsoft.com/en-us/library/w368ysh2.aspx">/FIXED</a> to the linker, specify a <a href="https://msdn.microsoft.com/en-us/library/f7f5138s.aspx">preferred load address</a>, and if that address is available, our DLL will end up there.</p>
<p>We can also modify the preferred load address of the DLL ourselves. It's just the <em>"ImageBase"</em> value in the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680339(v=vs.85).aspx">optional PE header</a>. Putting it all together, we get:</p>
<ol>
<li>Get the address of the host application via GetModuleHandle(nullptr).</li>
<li>Open the DLL as a regular file, modify the preferred load address, and close it.</li>
<li>LoadLibrary</li>
<li>???</li>
<li>DLL magically appears at our desired location. PROFIT!</li>
</ol>
<h1 id="epilogue">Epilogue</h1>
<p>I hope this was somewhat educational or at least mildly entertaining. I guess the main point I'm trying to get through is that linkers aren't magic, and you can move some of their work to runtime.</p>
<p>I still don't recommend using any of this in the real world, but perhaps there are some crazy cases in which it would be useful <em>(Just In Time compilers? dev-only code hot-swap?)</em>. Just please don't send ninjas my way when something explodes :D</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date"> 5 July 2017</div>
        
        <div class="article-taxonomies">
            
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br />This work by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Tomasz Stachowiak</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.<br />
                Powered by <a target="_blank" href="https://getzola.org/">Zola</a>, Theme based on <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              // customised options
              // • auto-render specific keys, e.g.:
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              // • rendering keys, e.g.:
              throwOnError : false
            });
        });
    </script>

</body>
</html>
